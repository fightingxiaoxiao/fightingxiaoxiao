<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>在macOS上安装pygrib</title>
      <link href="2024/05/24/2024-5-zai-macos-shang-an-zhuang-pygrib/"/>
      <url>2024/05/24/2024-5-zai-macos-shang-an-zhuang-pygrib/</url>
      
        <content type="html"><![CDATA[<h2 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h2><p>pygrib是一个用于读取和写入气象数据格式<code>.grib</code>的Python库，在macOS上安装时遇到如下报错：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">      src/pygrib/_pygrib.c:1256:10: fatal error: <span class="token string">'grib_api.h'</span> <span class="token function">file</span> not found      <span class="token comment">#include "grib_api.h"</span>               ^~~~~~~~~~~~      <span class="token number">214</span> warnings and <span class="token number">1</span> error generated.      error: <span class="token builtin class-name">command</span> <span class="token string">'/usr/bin/clang'</span> failed with <span class="token builtin class-name">exit</span> code <span class="token number">1</span>      <span class="token punctuation">[</span>end of output<span class="token punctuation">]</span>  note: This error originates from a subprocess, and is likely not a problem with pip.  ERROR: Failed building wheel <span class="token keyword">for</span> pygribFailed to build pygribERROR: Could not build wheels <span class="token keyword">for</span> pygrib, <span class="token function">which</span> is required to <span class="token function">install</span> pyproject.toml-based projects<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="参考方案"><a href="#参考方案" class="headerlink" title="参考方案"></a>参考方案</h2><p>这个<a href="https://github.com/jswhit/pygrib/issues/115">issue</a>提出了类似的问题，平台是Ubuntu。其解决方案如下：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> libeccodes-devpip <span class="token function">install</span> eccodes-python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>同样的思路迁移至macOS，通过homebrew安装<code>eccodes</code>，并通过pip安装<code>eccodes-python</code>，最终成功安装。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">brew <span class="token function">install</span> eccodespip <span class="token function">install</span> eccodes-python<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>此外，注意到<code>eccodes</code>包需要<code>hdf5</code>包作为依赖，同某些包依赖的<code>hdf5-mpi</code>形成冲突，后期需要注意。</p>]]></content>
      
      
      <categories>
          
          <category> 气象学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 气象学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在UE5中实现可编程的动态纹理</title>
      <link href="2024/05/10/2024-5-zai-ue5-zhong-shi-xian-ke-bian-cheng-de-dong-tai-wen-li/"/>
      <url>2024/05/10/2024-5-zai-ue5-zhong-shi-xian-ke-bian-cheng-de-dong-tai-wen-li/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>内存纹理创建</p><p>完整的源文件见下：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"CreateDynamicTexture.h"</span></span>UTexture2D <span class="token operator">*</span> <span class="token class-name">UCreateDynamicTexture</span><span class="token double-colon punctuation">::</span><span class="token function">CreateDynamicTexture</span><span class="token punctuation">(</span><span class="token keyword">int</span> Width<span class="token punctuation">,</span> <span class="token keyword">int</span> Height<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    int32 TextureWidth <span class="token operator">=</span> Width<span class="token punctuation">;</span>    int32 TextureHeight <span class="token operator">=</span> Height<span class="token punctuation">;</span>    UTexture2D <span class="token operator">*</span>NewTexture <span class="token operator">=</span> <span class="token class-name">UTexture2D</span><span class="token double-colon punctuation">::</span><span class="token function">CreateTransient</span><span class="token punctuation">(</span>TextureWidth<span class="token punctuation">,</span> TextureHeight<span class="token punctuation">,</span> PF_B8G8R8A8<span class="token punctuation">,</span> <span class="token function">FName</span><span class="token punctuation">(</span><span class="token string">"MyColorMap"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> NewTexture<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      <categories>
          
          <category> 可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 虚幻引擎 </tag>
            
            <tag> 材质 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时隔两年的测试</title>
      <link href="2024/05/08/2024-5-shi-ge-liang-nian-de-ce-shi/"/>
      <url>2024/05/08/2024-5-shi-ge-liang-nian-de-ce-shi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在OpenFOAM中实现动网格与流场的信息交互</title>
      <link href="2022/08/19/2022-8-zai-openfoam-zhong-shi-xian-dong-wang-ge-yu-liu-chang-de-xin-xi-jiao-hu/"/>
      <url>2022/08/19/2022-8-zai-openfoam-zhong-shi-xian-dong-wang-ge-yu-liu-chang-de-xin-xi-jiao-hu/</url>
      
        <content type="html"><![CDATA[<h2 id="物理模型简介"><a href="#物理模型简介" class="headerlink" title="物理模型简介"></a>物理模型简介</h2><p>在风吹雪、风吹沙、尘埃物输运等物理现象中，随着地表的颗粒物被风吹起，或是颗粒因为动能不足而发生沉积，其堆积形态会随着时间的推移而发生变化：</p><img src="https://smilemax-1300318971.cos.ap-chengdu.myqcloud.com/blogImage/2022-8/snowdrift.png" alt="风致雪漂形成的雪堆" style="zoom:40%;" /><p>下面就是一个用于描述这类现象的侵蚀/沉积模型<a href="#refer-anchor-1"><sup>[1]</sup></a>，作者认为边界处的剪切风速的大小和颗粒物浓度决定了颗粒床的侵蚀/沉积量，进而可以推算出底部边界的演化过程：</p><p>$$q_{\mathrm{dep}} = -\phi w_f \left(1-\frac{u_{*}^{2}}{u_{*t}^{2}}\right)$$</p><p>$$q_{\mathrm{ero}}=-A_\mathrm{ero} \left(u_{*}^{2}-u_{*t}^2\right)$$</p><h2 id="可编程的动网格边界"><a href="#可编程的动网格边界" class="headerlink" title="可编程的动网格边界"></a>可编程的动网格边界</h2><p>但是如果想在OpenFOAM中直接再现这个模型是会遇到麻烦的，因为常见的OpenFOAM动网格模型都是“强迫型”的。也就是说，网格的移动是需要事先指定的，流场的改变取决于网格的变化。这显然与我们的期望不符。因为在上述问题中，网格的变化来源于流场，而流场也会因为网格的变动发生进一步的改变，这两者之间存在耦合关系。</p><p>当然对于可定制性很强的OpenFOAM来说，解决这个问题只需要植入一段在算例中动态编译的代码。首先我们注意到动网格的边界条件来自于<code>0/pointMotionU</code>或<code>0/pointDisplacement</code>文件（取决于你使用的动网格求解器是基于速度还是位移），因此直接使用<code>codedFixedValue</code>这个重量级选手即可达到实时调整网格的目的。通过可编程接口，我们可以在定义边界条件中通过访问<code>patch().lookupPatchField</code>获取当前边界位置的场。例如我们已在自定义的求解器中创建了一个体标量场<code>deltaH</code>用于计算和存放网格格心和边界面心的侵蚀/沉积高度（非零值仅出现在特定边界），则可以通过下列方式在<code>codedFixedValue</code>的代码段中进行访问：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//仅访问当前边界的场</span>fvPatchField<span class="token operator">&lt;</span>scalar<span class="token operator">></span> <span class="token function">deltaH</span><span class="token punctuation">(</span><span class="token function">patch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>lookupPatchField<span class="token operator">&lt;</span>volScalarField<span class="token punctuation">,</span> scalar<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"deltaH"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="对节点边界的特殊化处理"><a href="#对节点边界的特殊化处理" class="headerlink" title="对节点边界的特殊化处理"></a>对节点边界的特殊化处理</h2><p>但是，无论<code>0/pointMotionU</code>还是<code>0/pointDisplacement</code>均属于<code>pointVectorField</code>，与之对应的边界类是<a href="https://www.openfoam.com/documentation/guides/v2112/api/classFoam_1_1pointPatch.html"><code>Foam::pointPatch</code></a>，其数据存储在格点上。而在有限体积法表述下的边界是<a href="https://www.openfoam.com/documentation/guides/v2112/api/classFoam_1_1fvPatch.html"><code>Foam::fvPatch</code></a>，其数据存储在面心。这就带来两个问题：</p><ol><li><code>deltaH</code>场不存在于<code>pointField</code>中，因此在定义动网格边界条件时，无法通过上述的<code>patch().lookupPatchField</code>进行查找。</li><li>格点数据和面心数据显然是无法对齐的，需要进行插值。</li></ol><p>第一个问题很好解决。<code>fvPatch</code>和<code>pointPatch</code>虽然存在差异，但它们的指向的patch编号是一致的，因此可以通过<code>this-&gt;db()</code>访问到全局的网格信息和场信息，然后提取对应编号的边界场。自此，我们获得了一个<code>deltaHp</code>场，它负责存储边界面心处的<code>deltaH</code>值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">label patchIndex <span class="token operator">=</span> <span class="token function">patch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 获取patch编号</span><span class="token comment">// 访问全局场</span><span class="token keyword">const</span> volScalarField <span class="token operator">&amp;</span><span class="token function">deltaH</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span><span class="token function">db</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>objectRegistry<span class="token operator">::</span>lookupObject<span class="token operator">&lt;</span>volScalarField<span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"deltaH"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> scalarField<span class="token operator">&amp;</span> deltaHp <span class="token operator">=</span> deltaH<span class="token punctuation">.</span><span class="token function">boundaryField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>patchIndex<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>第二个问题稍复杂一些，因为从单纯的CFD计算角度出发，基于体心的有限体积法没有将数据插值到节点的必要。不过幸运的是，OpenFOAM提供了一个<a href="https://www.openfoam.com/documentation/guides/v2112/api/classFoam_1_1PrimitivePatchInterpolation.html"><code>PrimitivePatchInterpolation</code></a>类，其中包含了从面向点插值的方法<code>faceToPointInterpolate</code>。简单看下源码，插值过程主要分为两步，首先是在节点上遍历所有从属的面，计算节点到面的距离，以倒数的形式计入面对点的权重并进行归一化，之后遍历所有面，把带权重的值累加进节点即可。本质上就是一个线性插值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//PrimitivePatchInterpolation&lt;Patch>::makeFaceToPointWeights</span><span class="token function">forAll</span><span class="token punctuation">(</span>pointFaces<span class="token punctuation">,</span> pointi<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">const</span> labelList<span class="token operator">&amp;</span> curFaces <span class="token operator">=</span> pointFaces<span class="token punctuation">[</span>pointi<span class="token punctuation">]</span><span class="token punctuation">;</span>scalarList<span class="token operator">&amp;</span> pw <span class="token operator">=</span> weights<span class="token punctuation">[</span>pointi<span class="token punctuation">]</span><span class="token punctuation">;</span> pw<span class="token punctuation">.</span><span class="token function">setSize</span><span class="token punctuation">(</span>curFaces<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>scalar sumw <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span><span class="token function">forAll</span><span class="token punctuation">(</span>curFaces<span class="token punctuation">,</span> facei<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        pw<span class="token punctuation">[</span>facei<span class="token punctuation">]</span> <span class="token operator">=</span>            <span class="token number">1.0</span><span class="token operator">/</span><span class="token function">mag</span><span class="token punctuation">(</span>faces<span class="token punctuation">[</span>curFaces<span class="token punctuation">[</span>facei<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">centre</span><span class="token punctuation">(</span>points<span class="token punctuation">)</span> <span class="token operator">-</span> points<span class="token punctuation">[</span>pointi<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sumw <span class="token operator">+=</span> pw<span class="token punctuation">[</span>facei<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">forAll</span><span class="token punctuation">(</span>curFaces<span class="token punctuation">,</span> facei<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        pw<span class="token punctuation">[</span>facei<span class="token punctuation">]</span> <span class="token operator">/=</span> sumw<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token comment">//PrimitivePatchInterpolation&lt;Patch>::faceToPointInterpolate</span><span class="token function">forAll</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> facei<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token keyword">const</span> labelList<span class="token operator">&amp;</span> curPoints <span class="token operator">=</span> localFaces<span class="token punctuation">[</span>facei<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">forAll</span><span class="token punctuation">(</span>curPoints<span class="token punctuation">,</span> pointi<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>result<span class="token punctuation">[</span>facei<span class="token punctuation">]</span> <span class="token operator">+=</span> pf<span class="token punctuation">[</span>curPoints<span class="token punctuation">[</span>pointi<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>result<span class="token punctuation">[</span>facei<span class="token punctuation">]</span> <span class="token operator">/=</span> curPoints<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原理搞明白了，接下来就只需要调用<code>primitivePatchInterpolation</code>就行了。<code>primitivePatchInterpolation</code>构造函数的形参是一个<code>PrimitivePatch</code>对象，我没有找到直接访问的方法。但是我们可以通过刚才获取的<code>deltaH</code>场反溯网格，即利用<code>deltaH.mesh().boundaryMesh()</code>获得<code>polyBoundaryMesh</code>，这是一个存储<code>polyPatch</code>的List，而<code>polyPatch</code>恰巧继承自<code>PrimitivePatch</code>。自此，整个插值过程得以完成，我们获得了一个名为<code>deltaHpp</code>的场，它对应边界上每个节点的<code>deltaH</code>值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 实例化插值对象</span>primitivePatchInterpolation <span class="token function">facePointInterp</span><span class="token punctuation">(</span>deltaH<span class="token punctuation">.</span><span class="token function">mesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">boundaryMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>patchIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>tmp<span class="token operator">&lt;</span>scalarField<span class="token operator">></span> deltaHpp <span class="token operator">=</span> facePointInterp<span class="token punctuation">.</span><span class="token function">faceToPointInterpolate</span><span class="token punctuation">(</span>deltaHp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 面心向节点插值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>最后，只需要将获得的高度变化场赋予边界的节点场即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">pointField <span class="token function">pVec</span><span class="token punctuation">(</span><span class="token function">deltaHpp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">forAll</span><span class="token punctuation">(</span>pVec<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>pVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>pVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deltaHpp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">==</span> pVec<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>相关的求解器代码和计算案例可见<a href="https://github.com/fightingxiaoxiao/driftScalarDyFoam">https://github.com/fightingxiaoxiao/driftScalarDyFoam</a> ，我也使用这个思路实现了对屋面积雪和方块周边积雪的简单预测<a href="#refer-anchor-2"><sup>[2]</sup></a>，相关论文发表于<a href="https://doi.org/10.3389/feart.2022.822140">https://doi.org/10.3389/feart.2022.822140</a> 。</p><img src="https://smilemax-1300318971.cos.ap-chengdu.myqcloud.com/blogImage/2022-8/output.gif" alt="方块周边的积雪演化" style="zoom:50%;" /><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a class="target-fix" id="refer-anchor-1"></a></p><p>[1] ZHOU X, KANG L, GU M, 等. Numerical simulation and wind tunnel test for redistribution of snow on a flat roof[J/OL]. Journal of Wind Engineering and Industrial Aerodynamics, 2016, 153: 92-105. <a href="https://doi.org/10.1016/j.jweia.2016.03.008">https://doi.org/10.1016/j.jweia.2016.03.008</a>.</p><p><a class="target-fix" id="refer-anchor-2"></a> </p><p>[2] CHEN X, YU Z. DriftScalarDyFoam: An OpenFOAM-Based Multistage Solver for Drifting Snow and Its Distribution Around Buildings[J/OL]. Frontiers in Earth Science, 2022, 10[2022-03-16]. <a href="https://www.frontiersin.org/article/10.3389/feart.2022.822140">https://www.frontiersin.org/article/10.3389/feart.2022.822140</a>.</p>]]></content>
      
      
      <categories>
          
          <category> CFD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFD </tag>
            
            <tag> OpenFOAM </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>macOS系统学习小记</title>
      <link href="2022/08/04/2022-8-macos-xue-xi-xiao-ji/"/>
      <url>2022/08/04/2022-8-macos-xue-xi-xiao-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="在内存上创建分区"><a href="#在内存上创建分区" class="headerlink" title="在内存上创建分区"></a>在内存上创建分区</h2><p>在内存上创建一个128MB的可读写分区</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">diskutil erasevolume HFS+ <span class="token string">'RAM Disk'</span> <span class="token variable"><span class="token variable">`</span>hdiutil attach -nomount ram://262144<span class="token variable">`</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>弹出名为<code>/dev/disk8</code>的分区</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hdiutil detach /dev/disk8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux工作站指南</title>
      <link href="2021/05/22/2021-5-linux-gong-zuo-zhan-zhi-nan/"/>
      <url>2021/05/22/2021-5-linux-gong-zuo-zhan-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从2021年5月20日起，工作站的操作系统从Windows 10迁移至Ubuntu 20.04。Linux作为最流行的服务器系统，广泛应用于HPC集群等高性能计算机设备。其主要优势包括：</p><p><strong>1. 可靠的稳健性。</strong>Linux的操作基于Linux shell，这意味着所有对Linux的操作实际上由命令行完成，包括桌面图形在内的所有上层设施都基于底层的脚本，这确保Linux在图形崩溃时仍能使用底层的tty执行命令行或恢复。大部分7×24小时开启的服务器均采用Linux系统。</p><p><strong>2. 良好的性能。</strong>Linux系统的内存占用普遍低于Windows,这得益于没有针对Linux的流氓软件，以及Linux良好的进程管理。由于采用ext4格式硬盘，Linux在小文件IO的性能方便也具备显著优势。</p><p><strong>3. 强大的开源生态链。</strong>在计算机仿真领域，几乎所有的开源程序都更偏向GNU/Linux生态。事实上，包括ANSYS,LSTC在内的商软在测试性能时也偏向使用Linux(比如RHEL)。</p><p><strong>4. 便利的网络配置。</strong>Linux几乎是组建计算机集群的唯一选择。</p><p><strong>5. 以上都是编的。</strong>主要原因是逼格够高。</p><h2 id="工作站配置介绍"><a href="#工作站配置介绍" class="headerlink" title="工作站配置介绍"></a>工作站配置介绍</h2><h2 id="系统的基本操作"><a href="#系统的基本操作" class="headerlink" title="系统的基本操作"></a>系统的基本操作</h2><p>本系统安装了Gnome桌面，也就是你们现在看到的这个图形界面。尽管很多软件像win10一样能用双击的方式打开，但这并不是一个很好的选择。因为使用这种方式打开的软件默认采用后台运行的方式，当后台运行的软件报错时，我们可能需要进入任务管理器才能强制中断并退出。Linux系统更推荐使用<strong>终端</strong>(<strong>Terminal</strong>)直接输入<strong>命令行</strong>进行操作。使用<code>Ctrl</code>+<code>Alt</code>+<code>T</code>或在资源管理器的空白位置<code>右键</code>-&gt;<code>Open in Terminal</code>可以快速打开一个终端窗口。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li><p>请务必在运行程序时注意终端命令的执行路径！错误的路径很可能会覆盖其他人的工作成果！在终端中执行<code>pwd</code>命令可以快速查看当前路径。</p></li><li><p>在运行大规模的计算时，请注意系统资源的占用情况！在终端中执行<code>top</code>或<code>htop</code>可以快速查看当前的CPU和内存使用情况。</p></li></ul><h2 id="主要CAE软件的使用方法"><a href="#主要CAE软件的使用方法" class="headerlink" title="主要CAE软件的使用方法"></a>主要CAE软件的使用方法</h2><h3 id="ANSYS-Fluent"><a href="#ANSYS-Fluent" class="headerlink" title="ANSYS Fluent"></a>ANSYS Fluent</h3><h3 id="ANSYS-LS-DYNA"><a href="#ANSYS-LS-DYNA" class="headerlink" title="ANSYS LS-DYNA"></a>ANSYS LS-DYNA</h3><p>目前，支持<strong>从LS-Run启动</strong>和<strong>从命令行启动</strong>两种执行方法。</p><h4 id="I-从LS-Run启动"><a href="#I-从LS-Run启动" class="headerlink" title="I. 从LS-Run启动"></a>I. 从LS-Run启动</h4><p>在终端执行<code>lsrun &amp;</code>，之后操作与Windows类似，在Preset选项中选择MPP/SMP和精度选项来指定求解器（请不要直接更改SOLVER路径！）。点击<code>LSPP</code>按钮执行后处理。</p><h4 id="II-从命令行启动"><a href="#II-从命令行启动" class="headerlink" title="II. 从命令行启动"></a>II. 从命令行启动</h4><h5 id="1-配置项目路径"><a href="#1-配置项目路径" class="headerlink" title="1. 配置项目路径"></a>1. 配置项目路径</h5><p>将你想要执行的k文件放到你的工作路径，打开终端，进入你的工作路径，例如</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /media/workstationData/lsdyna_example/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当然，如果你在资源管理器界面，在当前文件目录下采用右键的方式打开Terminal的话，Terminal默认的路径就会在当前路径下，可以执行<code>pwd</code>命令核实。</p><h5 id="2-执行LS-DYNA求解器"><a href="#2-执行LS-DYNA求解器" class="headerlink" title="2. 执行LS-DYNA求解器"></a>2. 执行LS-DYNA求解器</h5><p>LS-DYNA的求解器命令为<code>lsdyna</code>，其通过不同的可选命令来实现求解的设置，如：</p><p><code>-mpp</code> 使用MPP求解器，不附加该词条则使用SMP求解器</p><p><code>-np X</code> 使用X个计算节点启动MPP求解器</p><p><code>-dp</code> 使用双精度求解器，不附加该词条则使用单精度求解器</p><p><code>i=xxx.k</code> 指定需要执行的k文件，应确保k文件位于当前路径</p><p><code>memory=xxxxxx</code> 指定求解器占用内存，默认单位是字节，一般情况下不需要使用</p><p><code>ncpus=X</code> 使用X个线程启动SMP求解器。需要注意，按照官方文档的说明，当并行线程数大于5时，SMP的并行加速比可能会显著下降，此时更推荐使用MPP求解器。</p><p>以下给出一些实际运行案例：</p><ul><li>使用<code>1</code>个线程运行<code>单精度</code> <code>SMP</code>求解器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lsdyna <span class="token assign-left variable">i</span><span class="token operator">=</span>test.k<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用<code>4</code>个并行节点运行<code>单精度</code> <code>MPP</code>求解器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lsdyna -mpp -np <span class="token number">4</span> <span class="token assign-left variable">i</span><span class="token operator">=</span>test.k<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用<code>4</code>个线程运行<code>双精度</code> <code>SMP</code>求解器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lsdyna -dp <span class="token assign-left variable">i</span><span class="token operator">=</span>test.k <span class="token assign-left variable">ncpus</span><span class="token operator">=</span><span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用<code>8</code>个并行节点运行<code>双精度</code> <code>MPP</code>求解器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lsdyna -mpp -dp -np <span class="token number">8</span> <span class="token assign-left variable">i</span><span class="token operator">=</span>test.k<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>使用<code>8</code>个并行节点运行<code>双精度</code> <code>MPP</code>求解器，并指定2000M内存</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lsdyna -mpp -dp -np <span class="token number">8</span> <span class="token assign-left variable">i</span><span class="token operator">=</span>test.k <span class="token assign-left variable">memory</span><span class="token operator">=</span>2000M<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">lsdyna -mpp -dp -np <span class="token number">8</span> <span class="token assign-left variable">i</span><span class="token operator">=</span>test.k <span class="token assign-left variable">memory</span><span class="token operator">=</span><span class="token number">2000000000</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="3-使用LS-PrePost后处理"><a href="#3-使用LS-PrePost后处理" class="headerlink" title="3. 使用LS-PrePost后处理"></a>3. 使用LS-PrePost后处理</h5><p>在当前路径执行<code>lsprepost</code>即可，后续操作和Windows下一致。</p><h5 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h5><blockquote><p>重启工作站后MPP程序卡住</p></blockquote><p>这个问题可能是由于INTELMPI没有获取足够的权限导致的，可以尝试执行以下命令（<strong>如不了解管理员权限，请事先告知我！</strong>）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token function">sudo</span> <span class="token function">tee</span> /proc/sys/kernel/yama/ptrace_scope<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Abaqus"><a href="#Abaqus" class="headerlink" title="Abaqus"></a>Abaqus</h3><h3 id="OpenFOAM"><a href="#OpenFOAM" class="headerlink" title="OpenFOAM"></a>OpenFOAM</h3>]]></content>
      
      
      <categories>
          
          <category> 手册 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CAE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CFD-DPM的基本原理</title>
      <link href="2021/03/14/2021-3-cfd-dpm-de-ji-ben-yuan-li/"/>
      <url>2021/03/14/2021-3-cfd-dpm-de-ji-ben-yuan-li/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFD </tag>
            
            <tag> DPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大气边界层的数值方法实现：以OpenFOAM为例（一）</title>
      <link href="2020/12/13/2020-12-14-da-qi-bian-jie-ceng/"/>
      <url>2020/12/13/2020-12-14-da-qi-bian-jie-ceng/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>地球表面通过地面的摩擦对空气水平运动产生阻力，从而使气流速度减慢，该阻力对气流的作用随高度的增加而减弱。当超过特定高度 $(z_G)$ 时,这一作用即可被忽视，气流将沿等压线以梯度风速流动，则将此高度以下的区域称作<strong>大气边界层</strong>（<strong>Atmosphere Boundary Layer, ABL</strong>）。一般的，大气边界层内近地层的气流是湍流，湍流掺混使地表阻力的影响扩展到大气边界层的整个区域。而在边界层高度以上的自由大气中的风流动属于层流。<a href="#refer-anchor-1">[1]</a></p><h2 id="风速剖面"><a href="#风速剖面" class="headerlink" title="风速剖面"></a>风速剖面</h2><h3 id="对数律"><a href="#对数律" class="headerlink" title="对数律"></a>对数律</h3><p>平均风剖面是微气象学研究风速变化的一种主要方法。目前，气象学家认为用对数律表示大气底层强风风速廓线比较理想，其表达式为<a href="#refer-anchor-2">[2]</a><a href="#refer-anchor-3">[3]</a><br>$$u = \frac{u^*}{\kappa} \ln \left( \frac{z - d + z_0}{z_0} \right)\tag{1}$$<br>式中</p><p>$u$ — 高度 $z$ 处的平均风速（m/s）</p><p>$u^*$ — 剪切风速（m/s）</p><p>$\kappa$ — 卡曼常数，一般取0.4</p><p>$d$ — 零平均位移（m）</p><p>$z_0$ — 粗糙高度（m），取值可见下表<a href="#refer-anchor-1">[1]</a></p><table><thead><tr><th><strong>地面类型</strong></th><th><strong>$z_0/\rm{m}$</strong></th><th><strong>地面类型</strong></th><th><strong>$z_0/\rm{m}$</strong></th></tr></thead><tbody><tr><td>砂地</td><td>0.0001~0.001</td><td>矮棕榈</td><td>0.10~0.30</td></tr><tr><td>雪地</td><td>0.001~0.006</td><td>松树林</td><td>0.90~1.00</td></tr><tr><td>割过的草地（~0.01m）</td><td>0.001~0.01</td><td>稀疏建成市郊</td><td>0.20~0.40</td></tr><tr><td>矮草地、空旷草原</td><td>0.01~0.04</td><td>密集建成市郊、市区</td><td>0.80~1.20</td></tr><tr><td>休耕地</td><td>0.02~0.03</td><td>大城市中心</td><td>2.00~3.00</td></tr><tr><td>高草地</td><td>0.04~0.10</td><td></td><td></td></tr></tbody></table><p>城市地区的修正下次再写。</p><h3 id="指数律"><a href="#指数律" class="headerlink" title="指数律"></a>指数律</h3><p>&emsp;&emsp;懒得写了。</p><h2 id="湍流特征"><a href="#湍流特征" class="headerlink" title="湍流特征"></a>湍流特征</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a class="target-fix" id="refer-anchor-1"></a></p><p>[1] 黄本才. 结构抗风分析原理及应用[M]. 同济大学出版社, 2001.</p><p><a class="target-fix" id="refer-anchor-2"></a></p><p>[2] Yang Y, Gu M, Chen S, et al. New inflow boundary conditions for modelling the neutral equilibrium atmospheric boundary layer in computational wind engineering[J]. Journal of Wind Engineering and Industrial Aerodynamics, 2009, 97(2): 88-95.</p><p><a class="target-fix" id="refer-anchor-3"></a></p><p>[3] Richards P J, Hoxey R P. Appropriate boundary conditions for computational wind engineering models using the k-ε turbulence model[M]//Computational Wind Engineering 1. Elsevier, 1993: 145-153.</p>]]></content>
      
      
      <categories>
          
          <category> CFD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFD </tag>
            
            <tag> OpenFOAM </tag>
            
            <tag> Wind Engineering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenFOAM初探（二）</title>
      <link href="2020/02/18/2020-2-14-openfoam-study-2-blockmesh/"/>
      <url>2020/02/18/2020-2-14-openfoam-study-2-blockmesh/</url>
      
        <content type="html"><![CDATA[<h2 id="blockMesh命令"><a href="#blockMesh命令" class="headerlink" title="blockMesh命令"></a>blockMesh命令</h2><p><code>blockMesh</code> 是OpenFOAM中最基本的网格生成器之一，依赖于字典文件blockMeshDict。该程序以块(block)的思想来构造六面体(hexahedron)网格，类似于ICEM的结构化网格功能。blockMesh的主函数代码位于 /applications/utilities/mesh/generation/blockMesh/blockMesh.C 。关于该功能的详细介绍可以查阅<a href="https://cfd.direct/openfoam/user-guide/v7-blockmesh/#x26-1850005.3">Mesh generation with blockMesh</a></p><p>用法(Usage):</p><pre class="line-numbers language-none"><code class="language-none">blockMesh [OPTION]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项(Options):</p><p><strong>-case</strong> &lt;dir&gt;       指定案例所在目录，若缺省，则为当前路径。</p><p><strong>-dict</strong> &lt;filename&gt;  从指定路径读取blockMeshDict。</p><p><strong>-region</strong> &lt;name&gt;    只生成指定区域的网格。</p><p><strong>-blockTopology</strong>          将块的边缘和中心输出为.obj文件，以便进行可视化。</p><p><strong>-noFunctionObjects</strong>      跳过functionObjects的执行</p><h2 id="字典文件的书写"><a href="#字典文件的书写" class="headerlink" title="字典文件的书写"></a>字典文件的书写</h2><p><code>blockMesh</code> 指令依赖于字典文件blockMeshDict，该字典文件可位于</p><ul><li>system/blockMeshDict</li><li>system/&lt;region&gt;/blockMeshDict</li><li>constant/polyMesh/blockMeshDict</li><li>constant/&lt;region&gt;/polyMesh/blockMeshDict</li></ul><p>字典文件的内容包括：</p><h3 id="文件头-File-Header"><a href="#文件头-File-Header" class="headerlink" title="文件头(File Header)"></a>文件头(File Header)</h3><p>文件头用于申明字典类型。</p><pre class="line-numbers language-none"><code class="language-none">FoamFile&#123;    version     2.0;    format      ascii;    class       dictionary;    object      blockMeshDict;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="尺度缩放"><a href="#尺度缩放" class="headerlink" title="尺度缩放"></a>尺度缩放</h3><p>关键词 <code>convertToMeters</code> 用于定义几何缩放尺度，一般均转换为国际单位-米。</p><pre class="line-numbers language-none"><code class="language-none">convertToMeters 1.0;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="顶点定义"><a href="#顶点定义" class="headerlink" title="顶点定义"></a>顶点定义</h3><p>顶点关键词用于指定block顶点坐标，顶点编号从0开始。</p><pre class="line-numbers language-none"><code class="language-none">vertices(    (0. 0. 0.)    (1. 0. 0.));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="块定义"><a href="#块定义" class="headerlink" title="块定义"></a>块定义</h3><p>block是用八个顶点定义的六面体。第一个括号内书写八个顶点编号；第二个括号内书写x,y,z三个方向上的网格节点总数；simpleGrading后的括号可简单地定义节点分布律，表示x,y,z三个方向上的梯度率(<em>Grading Ratio</em>, 第一个网格尺寸/最后一个网格尺寸)(<strong>Fig. 1</strong>)。</p><pre class="line-numbers language-none"><code class="language-none">blocks(    hex (0 1 2 3 4 5 6 7) (10 10 10) simpleGrading (2 2 1));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>blockMesh</code> 同样也可以定义比较复杂的节点分布律。以下展示的脚本中，对block的y方向定义了3个子block,对每个子block施加不同的节点分布律。每个子括号的第一个数字代表子block在该方向上的几何尺寸权重，第二个数字代表子block在该方向上的节点数量权重，第三个数字代表梯度率。</p><pre class="line-numbers language-none"><code class="language-none">blocks(    hex (0 1 2 3 4 5 6 7) (10 10 10)     simpleGrading ( 1                    ((2 2 0.5)(3 6 0.2)(1 2 0.6))                    1                  ));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="曲边"><a href="#曲边" class="headerlink" title="曲边"></a>曲边</h3><p>此部分用于定义block中的曲线边缘，如几何中没有曲线可以将括号中内容缺省。<a href="https://cfd.direct/openfoam/user-guide/v7-blockmesh/#x26-1850005.3">Mesh generation with blockMesh</a>中有比较详细的介绍，此处不表。</p><pre class="line-numbers language-none"><code class="language-none">edges(    arc 1 5 (1.0 0.0 0.5));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="边界定义"><a href="#边界定义" class="headerlink" title="边界定义"></a>边界定义</h3><p>边界的定义是CFD分析的重要步骤。其结构包括：</p><ul><li>说明边界名称 —— inlet, outlet, any_name_u_like… </li><li>边界类型 —— patch表示后续需要赋予明确数值的边界，比如出入口；wall当然就是壁面；symmetry就是对称边界；其余定义尚在探索。</li><li>几何面 —— 表示该边界包含的block面。</li></ul><p>对于未定义的所有外露面，<code>blockMesh</code> 在执行过程中会有警告，并将这些面合并成一个集合。</p><pre class="line-numbers language-none"><code class="language-none">boundary               &#x2F;&#x2F; keyword    (        inlet              &#x2F;&#x2F; patch name        &#123;            type patch;    &#x2F;&#x2F; patch type for patch 0            faces            (                (0 4 7 3)  &#x2F;&#x2F; block face in this patch            );        &#125;                  &#x2F;&#x2F; end of 0th patch definition        outlet             &#x2F;&#x2F; patch name        &#123;            type patch;    &#x2F;&#x2F; patch type for patch 1            faces            (                (1 2 6 5)            );        &#125;        walls        &#123;            type wall;            faces            (                (0 1 5 4)                (0 3 2 1)                (3 7 6 2)                (4 5 6 7)            );        &#125;    );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="合并表面对"><a href="#合并表面对" class="headerlink" title="合并表面对"></a>合并表面对</h3><p>用于把两个不完全共节点的面熔接，反正对我而言没啥用，缺省。具体操作依然可见<a href="https://cfd.direct/openfoam/user-guide/v7-blockmesh/#x26-1850005.3">Mesh generation with blockMesh</a>(没错我就是这么懒:-))。</p><pre class="line-numbers language-none"><code class="language-none">mergePatchPairs();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="宏语法和动态编译（参数化）"><a href="#宏语法和动态编译（参数化）" class="headerlink" title="宏语法和动态编译（参数化）"></a>宏语法和动态编译（参数化）</h2><p>对于超过1个blcok的字典文件，顶点数超过了10个，后期修改简直要了懒人们的命。万幸的是，OpenFOAM的字典文件提供宏语法，比如在开头申明 <code>para 1.;</code> ，那在后续定义数字类参数时就可以用 <code>$para</code> 来表示。而对于需要进行数学计算的部分，可以采用 <code>#calc</code> 植入简单的计算语句：</p><pre class="line-numbers language-none"><code class="language-none">Y        5;Y_left   #calc &quot;-0.5*$Y&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>对于更复杂的需求，当然也可以直接植入C++代码片段。当然放这写显得杀鸡焉用牛刀，先给个<a href="https://cfd.direct/openfoam/user-guide/v7-basic-file-format/#x17-1230004.2">链接</a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>blockMesh</code> 从本质上讲就是一个脚本化的结构化网格生成器，对于一些简单模型，免去了在GUI上点来点去的麻烦，参数化的支持也能一定程度上改善几何参数化分析时的前处理效率。同时， <code>blockMesh</code> 在很多算例中都用于生成一个大流域，以进行下一步 <code>sanppyHexMesh</code> 的精细化非结构网格处理。</p>]]></content>
      
      
      <categories>
          
          <category> CFD </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFD </tag>
            
            <tag> OpenFOAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenFOAM初探（一）</title>
      <link href="2020/02/14/2020-2-openfoam-de-jie-shao-yu-an-zhuang/"/>
      <url>2020/02/14/2020-2-openfoam-de-jie-shao-yu-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者早年的工作主要在win10平台进行，使用过诸如CFX、Fluent等商业软件，后续论文工作主要操练的是Fluent UDF。诚然，Fluent依托UDF在可操作性上已经远超其余商业CFD软件(待考证)，但是其缺陷依然明显：1, 界面操作繁琐，对于一些参数化的研究工作，很难通过脚本实现(GUI依赖版本，TUI懒得学)；2, 新功能的整合程度参差不齐，以笔者常用的DPM为例，功能限制较多，BUG不少…；3, 很难修改顶层求解器，很多中间步骤需要手工；4, 安装包太大，正版太贵。<br>OpenFOAM是一款流行的开源CFD工具箱，最初萌生体验的想法主要还是觉得自己的代码水平有些上路了(自我感觉)，此外觉得用命令行和脚本操作很有一种Geek的感觉～</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>OpenFOAM主要有两大分支，一是<a href="https://www.openfoam.org/">基金会版(.org)</a>，版本号为OF6,7,8…，似乎是由帝国理工维护，从”血统”上讲更纯；二是<a href="https://www.openfoam.com/">ESI版(.com)</a>，版本号为v1912,v2006,v2012…(前两位数字代表年份，后两位数字代表月份，第一次接触乍一看还以为这版本好几年没更新了)，由ESI Group维护，有那么一点点商业化的感觉。通过使用OpenFOAM 7/8/v2006/v2012这四个版本, 我大致了解了一下这两个分支的区别：</p><ul><li><strong>手册</strong> <a href="https://openfoam.com/documentation/guides/latest/doc/">ESI版的手册</a>要远比基金会版的全面，后者基本就是看源码。当然总体来说OpenFOAM是我用过的大型开源软件里文档做的最差的，大概是为了培训收入吧。</li><li><strong>算例</strong> ESI版自带的Tutorials要比基金会版的多，比如大气边界层的建模，基金会版似乎没有。</li><li><strong>后处理</strong> ESI版DPM类的求解器输出的lagrangian粒子场能够通过外部安装的Paraview读取，而基金会版的只能通过在ThirdParty中编译的Paraview打开，而这个版本的显示性能较差。同时，如果使用的是WSL1这种没有显示接口的系统，使用Windows下的Paraview做颗粒后处理的话，ESI版是唯一的选择。</li><li><strong>求解器</strong> 基金会版似乎对一些求解器做了整合，比如将动网格功能合并进了一些原始的求解器，这一点比较友好。求解器功能上两者似乎差异不大。</li><li><strong>第三方包</strong> ESI版支持更多的第三方内容，比如比较知名的科学计算套件Petsc(很高端，很想学，但没空)、基于一些奇妙方法的多相流求解器OpenQBMM(但是算例好像跑不了…)、优化大规模IO的adios(听着很妙但没钱玩超算)…但是鲁迅说过，我可以不用，但它必须要有。</li><li><strong>平台支持</strong> 参考基金会官网，OpenFOAM主要面向Linux，同时也一定程度支持Windows 10和macOS。基金会提供了面向Linux的源码包，以及Ubuntu等主流Linux发行版的二进制包。在Win10上安装OpenFOAM(不包括虚拟机)需要安装Linux子系统，即WSL。而ESI版提供基于MSYS的OpenCFD,能在Windows上做到开箱即用(似乎就是个docker?)，针对不同发行版的二进制包也更多。不过平台的支持程度并不是很关键，因为想要好好学习OpenFOAM还是得从编译源码包开始，使用原生Linux无论从性能和兼容性来看都是最佳选择，WSL可以作为Windows系统上的备胎。否则OpenFOAM对比Fluent似乎没有明显优势。</li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="Arch-Manjaro"><a href="#Arch-Manjaro" class="headerlink" title="Arch/Manjaro"></a>Arch/Manjaro</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> pacman -S gcc flex cmake <span class="token function">git</span> openmpi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian/Ubuntu"></a>Debian/Ubuntu</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> build-essential flex bison cmake zlib1g-dev libboost-system-dev libboost-thread-dev libopenmpi-dev openmpi-bin gnuplot libreadline-dev libncurses-dev libxt-dev<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> qt4-dev-tools libqt4-dev libqt4-opengl-dev freeglut3-dev libqtwebkit-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CFD </tag>
            
            <tag> OpenFOAM </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020新春快乐！</title>
      <link href="2020/02/13/2020-02-2020-happy-new-year/"/>
      <url>2020/02/13/2020-02-2020-happy-new-year/</url>
      
        <content type="html"><![CDATA[<p>这是我的第一篇博客，写于新冠病毒肆虐的2020年新春。曾经也有过搭建个人网站的念头，但苦于学业繁忙一直不能如愿。如今踏入博一，课业轻了，第一篇SCI也已投出，自觉应该静下心来整理整理一些囫囵吞枣的知识，好好思索一下自己的科研计划。于是这个博客就华丽地诞生了！<br>往后，包括自己对所在科研领域的一些小小见解、平日学习的一些笔记都会逐步整理并上传。主要目的是便于对自己知识体系的整理和重用，也希望漂亮的博客能给予自己一个正反馈。如果你是偶然路过的同行，也十分欢迎互相交流学习。</p>]]></content>
      
      
      <categories>
          
          <category> 日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
